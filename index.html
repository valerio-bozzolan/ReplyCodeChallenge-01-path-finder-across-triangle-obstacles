<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Path finder across simple obscacles</title>
<style>
	#controls {
		position: fixed;
	}
	svg .obstacle {
		fill: yellow;
		fill-opacity:0.5;
		stroke: black;
		stroke-width: 5;
	}
	svg .platform {
		fill: blue;
		stroke: black;
		stroke-width: 5;
	}
	svg .warn-fill {
		fill: orange;
	}
	svg .warn-stroke {
		stroke: red;
		stroke-width: 15;
	}
	svg .info {
		stroke: green;
		fill: green;
	}
	svg .path-finder {
		stroke: blue;
		stroke-width:10;
	}
</style>
</head>
<body>
<h1>Path finder across simple obscacles</h1>
<div id="controls">
	<p>
		<button id="run">run</button>
		<button id="step">single step</button>
		<button id="pause">toggle pause</button>
	</p>
	<p>
		<textarea id="input"></textarea>
		<textarea id="output"></textarea>
	</p>
</div>
<div id="container">
	<svg id="canvas"></svg>
</div>
<script src="d3/d3.min.js"></script>
<script>
"use strict";

var Data = {
	/**
	 * Remove duplicate obstacles
	 */
	removeDuplicateObstacles: function () {
		var uniques = [];
		var obstacles = this.obstacles;
		for( var i = 0; i < obstacles.length - 1; i++ ) {
			var found = false;
			for( var j = i + 1; j < obstacles.length; j++ ) {
				if( obstacles[ j ].containsTriangle( obstacles[ i ] ) ) {
					found = true;
					break;
				}
			}
			if( ! found ) {
				uniques.push( obstacles[ i ] );
			}
		}
		this.obstacles = uniques;
	}
};

/**
 * Create a new point from two coordinates
 *
 * @param x float
 * @param y float
 */
function Point ( x, y ) {
	this.x = x;
	this.y = y;
};

/**
 * Is this point the same of another point?
 *
 * @param p {Point}
 * @return {bool}
 */
Point.prototype.equals = function ( p ) {
	return this.x === p.x
	    && this.y === p.y;
};

/**
 * Create a new point from two string coordinates
 *
 * @param x string
 * @param y string
 * @return Point
 */
Point.createFromString = function ( x, y ) {
	return new Point(
		parseFloat( x ),
		parseFloat( y )
	);
};

/**
 * Get the distance from this point and another
 *
 * @param p {Point}
 * @return {float}
 */
Point.prototype.distanceFrom = function ( p ) {
	var a = this.x - p.x,
	    b = this.y - p.y;
	return Math.sqrt( a * a + b * b );
};

/**
 * Create a new segment from two points
 *
 * @param a {Point}
 * @param b {Point}
 */
function Segment ( a, b ) {
	this.a = a;
	this.b = b;
};

/**
 * SVG points attribute
 *
 * @return {string}
 */
Segment.prototype.getSVGPoints = function () {
	return '' + this.a.x + ',' + this.a.y
	    + ' ' + this.b.x + ',' + this.b.y;
};

/**
 * Check if this segment is the continuation of another one
 *
 * @param segment {Segment}
 * @return {bool}
 */
Segment.prototype.isContigueWith = function ( segment ) {
	var a =    this.a,
	    b =    this.b,
	    c = segment.a,
	    d = segment.b;
	return a.equals( c ) || a.equals( d ) || b.equals( c ) || b.equals( d );
};

/**
 * Does this segment intersect another segment?
 *
 * @return {bool}
 * @see http://paulbourke.net/geometry/pointlineplane/
 */
Segment.prototype.getIntersection = function ( segment ) {
	if( this.isContigueWith( segment ) ) {
		return false;
	}
	var r = this, s = segment;
	var x1 = r.a.x, y1 = r.a.y,
		x2 = r.b.x, y2 = r.b.y,
		x3 = s.a.x, y3 = s.a.y,
		x4 = s.b.x, y4 = s.b.y;
	var denominator = ( y4 - y3 ) * ( x2 - x1 )
	                - ( x4 - x3 ) * ( y2 - y1 );
	if( 0.0 !== denominator ) {
		var ur = ( x4 - x3 ) * ( y1 - y3 )
		       - ( y4 - y3 ) * ( x1 - x3 ),
			us = ( x2 - x1 ) * ( y1 - y3 )
			   - ( y2 - y1 ) * ( x1 - x3 );
		ur /= denominator;
		us /= denominator;
		if( ur >= 0 && ur <= 1 && us >= 0 && us <= 1 ) {
			return new Point(
				x1 + ur * ( x2 - x1 ),
				y1 + ur * ( y2 - y1 )
			);
		}
	}
	return false;
};

/**
 * Get the length of this segment
 *
 * @return {float}
 */
Segment.prototype.getLength = function () {
	return this.a.distanceFrom( this.b );
};

/**
 * Create a segment collision (a segment with a point)
 *
 * @param segment {Segment}
 * @param point {Point}
 */
function SegmentCollision ( segment, point ) {
	this.segment   = segment;
	this.collision = point;
};

/**
 * Create a new triangle
 *
 * @param a {Point}
 * @param b {Point}
 * @param c {Point}
 */
function Triangle ( a, b, c ) {
	this.a = a;
	this.b = b;
	this.c = c;
};

/**
 * Get all the points
 *
 * @return {array}
 */
Triangle.prototype.getPoints = function () {
	return [ this.a, this.b, this.c ];

};

/**
 * Does this object has a certain point (in the perimeter)?
 *
 * @return {bool}
 */
Triangle.prototype.hasPoint = function ( p ) {
	var points = this.getPoints();
	for( var i = 0; i < points.length; i++ ) {
		if( p.equals( points[ i ] ) ) {
			return true;
		}
	}
	return false;
};

/**
 * SVG points attribute
 *
 * @param t {Triangle}
 * @return {string}
 */
Triangle.prototype.getSVGPoints = function () {
	return '' + this.a.x + ',' + this.a.y
	    + ' ' + this.b.x + ',' + this.b.y
	    + ' ' + this.c.x + ',' + this.c.y;
};

/**
 * Get the segments (sides) of this triangle
 *
 * @return {array}
 */
Triangle.prototype.getSegments = function () {
	if( undefined === this._segments ) {
		this._segments = [
			new Segment( this.a, this.b ),
			new Segment( this.b, this.c ),
			new Segment( this.c, this.a )
		];
	}
	return this._segments;
}

/**
 * Get the perimeter of this triangle
 *
 * @return {float}
 */
Triangle.prototype.getPerimeter = function () {
	if( undefined === this._perimeter ) {
		var segments = this.getSegments();
		this._perimeter = 0;
		for( var i = 0; i < segments.length; i ++ ) {
			this._perimeter += segments[ i ].getLength();
		}
	}
	return this._perimeter;
}

/**
 * Get the area of this triangle
 *
 * @see Heron's Formula
 * @return {float}
 */
Triangle.prototype.getArea = function () {
	if( undefined === this._area ) {
		var a = this.a,
		    b = this.b,
		    c = this.c;
		var p = this.getPerimeter() / 2;
		this._area = Math.sqrt(
			p * ( p - a.distanceFrom( b ) )
			  * ( p - b.distanceFrom( c ) )
			  * ( p - c.distanceFrom( a ) )
		);
	}
	return this._area;
}

/**
 * Get the segments of this triangles that were eventually intersected
 * by another segment.
 *
 * @param segmentTest {Segment}
 * @return {array}
 */
Triangle.prototype.getSegmentCollisions = function ( segmentTest ) {
	var collisions = [];
	var segments = this.getSegments();
	for( var i = 0; i < segments.length; i++ ) {
		var intersection = segmentTest.getIntersection( segments[ i ] );
		if( intersection ) {
			collisions.push( new SegmentCollision( segments[ i ], intersection ) );
		}
	}
	return collisions;
};

/**
 * Is this point inside this triangle?
 *
 * @param p {Point}
 * @return {bool}
 */
Triangle.prototype.containsPoint = function ( p ) {
	var a = this.a,
	    b = this.b,
	    c = this.c;
	var v0 = [ c.x - a.x, c.y - a.y ],
	    v1 = [ b.x - a.x, b.y - a.y ],
	    v2 = [ p.x - a.x, p.y - a.y ];
	var dot00 = v0[0] * v0[0] + v0[1] * v0[1],
	    dot01 = v0[0] * v1[0] + v0[1] * v1[1],
	    dot02 = v0[0] * v2[0] + v0[1] * v2[1],
	    dot11 = v1[0] * v1[0] + v1[1] * v1[1],
	    dot12 = v1[0] * v2[0] + v1[1] * v2[1];
	var invDenom = 1 / ( dot00 * dot11 - dot01 * dot01 );
	var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom,
	    v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	return u >= 0 && v >= 0 && (u + v) < 1;
};

/**
 * Does this triangle contains another triangle?
 *
 * @param t {Triangle}
 * @param mustBeInside {bool}
 * @return bool
 */
Triangle.prototype.containsTriangle = function ( t ) {
	var points = t.getPoints();
	for( var i = 0; i < points.length; i++ ) {
		if( ! t.containsPoint( points[ i ] ) ) {
			return false;
		}
	}
	return true;
};

/**
 * Rappresent a triangle with its segment collisions
 *
 * @param triangle {Triangle}
 * @param segmentCollisions {array}
 */
function TriangleCollisions( triangle, segmentCollisions ) {
	this.triangle = triangle;
	this.segmentCollisions = segmentCollisions;
};

/**
 * Filter an array of TriangleCollisions[] and get the nearest to a certain point
 *
 * @param trianglesCollisions {array}
 * @param point {Point}
 * @return {TriangleCollisions}
 */
TriangleCollisions.filterNearestToPoint = function ( trianglesCollisions, p ) {
	var nearest, nearestDistance;
	for( var i = 0; i < trianglesCollisions.length; i++ ) {
		var triangleCollision = trianglesCollisions[ i ];
		for( var j = 0; j < triangleCollision.segmentCollisions.length; j++ ) {
			var segmentCollision = triangleCollision.segmentCollisions[ j ];
			var distance = p.distanceFrom( segmentCollision.collision );
			if( 0 === i && 0 === j || distance < nearestDistance ) {
				nearest         = segmentCollision;
				nearestDistance = distance;
			}
		}
	}
	return nearest;
};

/**
 * Create a path
 */
function Path() {
	this.points = [];
};

/**
 * Filter some paths to pick the best of them
 *
 * @param paths {array}
 * @return {false|Path}
 */
Path.filterBest = function ( paths ) {
	var best = false, bestLength;
	for( var i = 0; i < paths.length; i++ ) {
		var path = paths[ i ];
		if( path ) {
			var length = path.getLength();
			if( best === false || length < bestLength ) {
				best = path;
				bestLength = length;
			}
		}
	}
	return best;
};

/**
 * Add a point to the path
 *
 * @param p {Point}
 */
Path.prototype.add = function ( p ) {
	this.points.push( p );
	return this;
};

/**
 * Get the latest point of the path
 *
 * @return {Point}
 */
Path.prototype.getLastPoint = function () {
	return this.points[ this.points.length - 1 ];
};

/**
 * Get the length of this path
 *
 * @return {int}
 */
Path.prototype.getLength = function () {
	var d = 0, last = this.points[ 0 ];
	for( var i = 1; i < this.points.length; i++ ) {
		var next = this.points[ i ];
		d += last.distanceFrom( next );
		last = next;
	}
	return d;
};

/**
 * Clone this path
 *
 * @return {Path}
 */
Path.prototype.clone = function () {
	var path = new Path();
	for( var i = 0; i < this.points.length; i++ ) {
		path.add( this.points[ i ] );
	}
	return path;
};

/**
 * Is this point in the path?
 *
 * @param p {Point}
 * @return {bool}
 */
Path.prototype.hasPoint = function ( p ) {
	var points = this.points;
	for( var i = 0; i < points.length; i++ ) {
		if( p.equals( points[ i ] ) ) {
			return true;
		}
	}
	return false;
};

/**
 * Get the solution
 *
 * @return {string|false}
 */
Path.prototype.getPrintableSolution = function () {
	var s = '', points = this.points;
	if( points.length > 1 ) {
		s = '' + points.length + '\n';
		for( var i = 0; i < points.length; i++ ) {
			s += points[ i ].x + ' ' + points[ i ].y + '\n';
		}
	}
	return false;
};

/**
 * SVG points attribute
 *
 * @return string
 */
Path.prototype.getSVGPoints = function () {
	var s = '', points = this.points;
	for( var i = 0; i < points.length; i++ ) {
		if( 0 !== i ) {
			s += ' ';
		}
		s += points[ i ].x + ',' + points[ i ].y;
	}
	return s;
};

/**
 * Instantiate the Path Finder
 */
function PathFinder ( start, target, obstacles, d3container ) {
	this.obstacles = obstacles;
	this.d3container = d3container;
	this.target = target;
	this.paths = [];
	this.deadSteps = new Path();
	this.running = false;
	this.pause = false;
	this.stack = [
		new PathFinderStatus( start, ( new Path() ) )
	];
};

/**
 * Push an element in the Path Finder stack
 *
 * @param status {PathFinderStatus}
 */
PathFinder.prototype.push = function ( status ) {
	this.stack.push( status );
};

/**
 * PathFinder stack status
 *
 * @param next {Point} The next point that we can try to add into the path
 * @param path {Path} The path that have not to be touched
 */
function PathFinderStatus( next, path ) {
	this.next = next;
	this.path = path;
};

/**
 * Run the path finder alghoritm
 *
 * @param onSolution {function}
 */
PathFinder.prototype.run = function ( onSolution ) {
	var t = this;
	this.interval = setInterval( function () {
		t.step( onSolution );
	}, 1 );
};

/**
 * Do a single step
 *
 * @param onSolution {function}
 */
PathFinder.prototype.step = function ( onSolution ) {
	if( this.running || this.pause ) {
		return;
	}
	this.running = true;
	if( this.stack.length ) {
		var path = this.operate( this.stack.pop() );
		if( path && path.hasPoint( this.target ) ) {
			this.paths.push( path );
		}
	} else {
		onSolution( Path.filterBest( this.paths ) );
	}
	this.running = false;
};

/**
 * Set/unset pause
 */
PathFinder.prototype.togglePause = function () {
	this.pause = ! this.pause;
};

/**
 * @param status {PathFinderStatus}
 * @return {Path}
 */
PathFinder.prototype.operate = function ( status ) {
	var d3container = this.d3container.html( null );
	var obstacles   = this.obstacles;
	var target = this.target;
	var next   = status.next;
	var path   = status.path;

	console.log( "next:" );
	console.log( next );

	d3container.append( 'circle' )
		.attr( 'class', 'choice' )
		.attr( 'cx', function () {
			return next.x;
		} )
		.attr( 'cy', function () {
			return next.y;
		} )
		.attr( 'r', 30 );

	// don't go backward
	if( path.hasPoint( next ) ) {
		console.log( "don't go backward" );
		return;
	}

	// check if the next point is inside an obstacle
	var obstaclesContainingNext = [];
	for( var i = 0; i < obstacles.length; i++ ) {
		var obstacle = obstacles[ i ];
		if( obstacle.containsPoint( next ) && ! obstacle.hasPoint( next ) ) {
			obstaclesContainingNext.push( obstacle );
		}
	}

	// try another next step (hoping to don't be into an obstacle)
	if( obstaclesContainingNext.length ) {
		console.log( "next is inside obstacles:" );
		console.log( obstaclesContainingNext );
		this.deadSteps.add( next );
		for( var i = 0; i < obstaclesContainingNext.length; i++ ) {
			var obstacle = obstacles[ i ];
			d3container.append( 'polygon' )
				.attr( 'class', 'collision warn-fill' )
				.attr( 'points', function () {
					return obstacle.getSVGPoints();
				} );
			var points = obstacle.getPoints();
			for( var j = 0; j < points.length; j++ ) {
				var point = points[ j ];
				if( ! this.deadSteps.hasPoint( point ) ) {
					this.push( new PathFinderStatus( point, path.clone() ) );
				}
			}
		}
		return;
	}

	// this point has not collisions
	path = path.add( next );
	d3container.append( 'polyline' )
		.attr( 'class', 'path-finder' )
		.attr( 'points', function () {
			return path.getSVGPoints();
		} );

	console.log( "current path:" );
	console.log( path );

	// virtual segment next-target
	var segment = new Segment( next, target );
	d3container.append( 'polyline' )
		.attr( 'class', 'path-finder warn-stroke' )
		.attr( 'points', function () {
			return segment.getSVGPoints();
		} );

	console.log("next→target:");
	console.log( segment );

	// virtual segment collisions
	var trianglesCollisions = [];
	for( var i = 0; i < obstacles.length; i++ ) {
		var obstacle = obstacles[ i ];
		var collidingSegments = obstacle.getSegmentCollisions( segment );
		if( collidingSegments.length ) {
			trianglesCollisions.push( new TriangleCollisions( obstacle, collidingSegments ) );
		}
	}

	console.log("next→target collisions:");
	console.log( trianglesCollisions );

	// plot collisions
	d3container.selectAll( '.collision' )
		.data( trianglesCollisions )
		.enter()
			// plot triangles involved in collisions
			.append( 'polygon' )
				.attr( 'class', 'collision warn-fill' )
				.attr( 'points', function ( trianglesCollisions ) {
					return trianglesCollisions.triangle.getSVGPoints();
				} )
				.each( function ( triangleCollisions ) {
					var parentNode = d3.select( this.parentNode )
						.selectAll( 'g' )
						.data( triangleCollisions.segmentCollisions )
						.enter();
						// plot triangle's segments involved in collision
						parentNode
							.append( 'polyline' )
								.attr( 'class', 'collision warn-stroke' )
								.attr( 'points', function ( segmentCollision ) {
									return segmentCollision.segment.getSVGPoints();
								} );
						// plot precise collision on triangle segments
						parentNode
							.append( 'circle' )
								.attr( 'class', 'collision warn-stroke warn-fill' )
								.attr( 'cx', function ( segmentCollision ) {
									return segmentCollision.collision.x;
								} )
								.attr( 'cy', function ( segmentCollision ) {
									return segmentCollision.collision.y;
								} )
								.attr( 'r', 10 );
				} );
	//\end plot collisions

	// no collisions?
	if( ! trianglesCollisions.length ) {
		return path; // end
	}

	// find the nearest collision
	var nearest = TriangleCollisions.filterNearestToPoint( trianglesCollisions, next );

	// chose one of the two next points
	var next1 = nearest.segment.a,
	    next2 = nearest.segment.b;

	// divide et impera
	this.push( new PathFinderStatus( next1, path.clone() ) );
	this.push( new PathFinderStatus( next2, path.clone() ) );

	// plot nexts
	d3container
		.selectAll( '.nexts' )
		.data( [ next1, next2 ] )
		.enter()
			.append( 'circle' )
			.attr( 'class', 'nexts' )
			.attr( 'cx', function ( p ) {
				return p.x;
			} )
			.attr( 'cy', function ( p ) {
				return p.y;
			} )
			.attr( 'r', 10 );
};

// textareas
var $in  = d3.select( '#input' ),
    $out = d3.select( '#output' );

// specify the data file
var fileNumber = 1,
    fileName = 'input_' + fileNumber + '.txt',
    filePath = 'inputs/' + fileName;

// retrieve via AJAX
var oReq = new XMLHttpRequest();
oReq.overrideMimeType( 'text/plain' ); // added for a file:/// bug
oReq.addEventListener( 'load', function () {

	$in.text( this.responseText );

	// parsing
	var lines = this.responseText.split('\n');
	var firstLine = lines[ 0 ].trim().split(' ');

	// initialization
	Data.from = Point.createFromString( firstLine[ 0 ], firstLine[ 1 ] );
	Data.to   = Point.createFromString( firstLine[ 2 ], firstLine[ 3 ] );
	Data.nObstacles = lines[ 1 ];
	Data.obstacles = [];

	// bounds
	var minX = Math.min( Data.from.x, Data.to.x ),
		maxX = Math.max( Data.from.x, Data.to.x ),
		minY = Math.min( Data.from.y, Data.to.y ),
		maxY = Math.max( Data.from.y, Data.to.y );

	// obstacles
	for( var i = 2; i < Data.nObstacles; i++ ) {
		var coordinates = lines[ i ].trim().split(' ');
		var a = Point.createFromString( coordinates[ 0 ], coordinates[ 1 ] ),
			b = Point.createFromString( coordinates[ 2 ], coordinates[ 3 ] ),
			c = Point.createFromString( coordinates[ 4 ], coordinates[ 5 ] );
		minX = Math.min( minX, a.x, b.x, c.x );
		maxX = Math.max( maxX, a.x, b.x, c.x );
		minY = Math.min( minY, a.y, b.y, c.y );
		maxY = Math.max( maxY, a.y, b.y, c.y );
		Data.obstacles.push( new Triangle( a, b, c ) );
	}

	// remove duplicate obstacles
	//Data.removeDuplicateObstacles();

	// SVG
	var svg = d3.select( 'svg' );
	var container = svg.append( 'g' );

	// zoom abilitation
	container.call( d3.zoom().on('zoom', function () {
		container.attr( 'transform', d3.event.transform );
	} ) );

	// viewbox fitting the content bounds
	var padding = 200;
	svg.attr( 'viewBox', '' +
			(          minX   - padding ) + ' ' +
			(          minY   - padding ) + ' ' +
			( ( maxX - minX ) + padding ) + ' ' +
			( ( maxY - minY ) + padding )
		);

	// plot triangles
	container.append('g')
		.selectAll( '.obstacle' )
		.data( Data.obstacles )
		.enter()
			.append( 'polygon' )
				.attr( 'class', 'obstacle' )
				.attr( 'points', function ( t ) {
					return t.getSVGPoints();
				} );

	// plot initial A B points
	container.append('g')
		.selectAll( '.platform' )
		.data( [
			Data.from,
			Data.to
		] )
		.enter()
			.append( 'circle' )
				.attr( 'class', 'platform' )
				.attr( 'cx', function ( p ) {
					return p.x;
				} )
				.attr( 'cy', function ( p ) {
					return p.y;
				} )
				.attr( 'r', 10 );

	// debug canvas
	var canvas = container.append( 'g' )
		.attr( 'class', 'temp' );

	// callback
	function onSolution ( path ) {
		$out.html( path && path.getPrintableSolution() || 'IMPOSSIBLE' );
	};

	var pathFinder = new PathFinder( Data.from, Data.to, Data.obstacles, canvas );

	window.pathFinder = pathFinder;

	d3.select( '#step' ).on( 'click', function () {
		pathFinder.step( onSolution );
	} );
	d3.select( '#run' ).on( 'click', function () {
		pathFinder.run( onSolution );
	} );
	d3.select( '#pause' ).on( 'click', function () {
		pathFinder.togglePause();
	} );
} );

// request the data
oReq.open( 'GET', filePath );
oReq.send();
</script>
</body>
</html>
